// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: batch.go

package repository

import (
	"context"
	"errors"
	"time"

	"github.com/jackc/pgx/v5"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const insertReviewImages = `-- name: InsertReviewImages :batchexec
INSERT INTO review_image (review_id, image_url)
VALUES ($1, $2) ON CONFLICT (review_id, image_url) DO NOTHING
`

type InsertReviewImagesBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertReviewImagesParams struct {
	ReviewID string `json:"review_id"`
	ImageUrl string `json:"image_url"`
}

func (q *Queries) InsertReviewImages(ctx context.Context, arg []InsertReviewImagesParams) *InsertReviewImagesBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ReviewID,
			a.ImageUrl,
		}
		batch.Queue(insertReviewImages, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertReviewImagesBatchResults{br, len(arg), false}
}

func (b *InsertReviewImagesBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertReviewImagesBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertReviewReplies = `-- name: InsertReviewReplies :batchexec
INSERT INTO review_reply (
        review_id,
        text,
        created_at
    )
VALUES ($1, $2, $3) ON CONFLICT (review_id) DO
UPDATE
SET text = EXCLUDED.text,
    created_at = EXCLUDED.created_at
`

type InsertReviewRepliesBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertReviewRepliesParams struct {
	ReviewID  string    `json:"review_id"`
	Text      string    `json:"text"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) InsertReviewReplies(ctx context.Context, arg []InsertReviewRepliesParams) *InsertReviewRepliesBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ReviewID,
			a.Text,
			a.CreatedAt,
		}
		batch.Queue(insertReviewReplies, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertReviewRepliesBatchResults{br, len(arg), false}
}

func (b *InsertReviewRepliesBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertReviewRepliesBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertReviews = `-- name: InsertReviews :batchexec
INSERT INTO review (
        id,
        user_id,
        rating,
        text,
        created_at,
        place_id,
        price_range
    )
VALUES ($1, $2, $3, $4, $5, $6, $7) ON CONFLICT (id) DO
UPDATE
SET user_id = EXCLUDED.user_id,
    rating = EXCLUDED.rating,
    text = EXCLUDED.text,
    created_at = EXCLUDED.created_at,
    weight = EXCLUDED.weight,
    place_id = EXCLUDED.place_id,
    price_range = EXCLUDED.price_range,
    summary = EXCLUDED.summary,
    business_summary = EXCLUDED.business_summary
`

type InsertReviewsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertReviewsParams struct {
	ID         string    `json:"id"`
	UserID     string    `json:"user_id"`
	Rating     int32     `json:"rating"`
	Text       string    `json:"text"`
	CreatedAt  time.Time `json:"created_at"`
	PlaceID    string    `json:"place_id"`
	PriceRange *int32    `json:"price_range"`
}

func (q *Queries) InsertReviews(ctx context.Context, arg []InsertReviewsParams) *InsertReviewsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.UserID,
			a.Rating,
			a.Text,
			a.CreatedAt,
			a.PlaceID,
			a.PriceRange,
		}
		batch.Queue(insertReviews, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertReviewsBatchResults{br, len(arg), false}
}

func (b *InsertReviewsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertReviewsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertUsers = `-- name: InsertUsers :batchexec
INSERT INTO "user" (
        id,
        name,
        photo_uri,
        review_count,
        photo_count,
        rating_count,
        is_local_guide,
        score
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8) ON CONFLICT (id) DO
UPDATE
SET name = EXCLUDED.name,
    photo_uri = EXCLUDED.photo_uri,
    review_count = EXCLUDED.review_count,
    photo_count = EXCLUDED.photo_count,
    rating_count = EXCLUDED.rating_count,
    is_local_guide = EXCLUDED.is_local_guide,
    score = EXCLUDED.score
`

type InsertUsersBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertUsersParams struct {
	ID           string  `json:"id"`
	Name         string  `json:"name"`
	PhotoUri     *string `json:"photo_uri"`
	ReviewCount  int32   `json:"review_count"`
	PhotoCount   int32   `json:"photo_count"`
	RatingCount  int32   `json:"rating_count"`
	IsLocalGuide bool    `json:"is_local_guide"`
	Score        int32   `json:"score"`
}

func (q *Queries) InsertUsers(ctx context.Context, arg []InsertUsersParams) *InsertUsersBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.Name,
			a.PhotoUri,
			a.ReviewCount,
			a.PhotoCount,
			a.RatingCount,
			a.IsLocalGuide,
			a.Score,
		}
		batch.Queue(insertUsers, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertUsersBatchResults{br, len(arg), false}
}

func (b *InsertUsersBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertUsersBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
